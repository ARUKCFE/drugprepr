---
title: "Using the new drugprepr user interface"
author: David Selby
date: October 2021
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using the new drugprepr user interface}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This is a development document and may be removed or hidden when the package is
released.

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(drugprepr)
example_therapy
```

## Universe

Recall the original user interface is implemented as follows.

```{r}
run.drugPREP
```

That is, we perform the following steps in series:

1. Implausible total quantity
2. Missing total quantity
3. Implausible daily dose
4. Missing daily dose
5. Clean duration
6. Select stop date type
7. Missing stop date (i.e. impute missing durations)
8. Multiple prescriptions with same start date
9. Overlapping prescriptions
10. Gaps between prescriptions

With the new user interface:

```{r}
plausible_values <- data.frame(
  prodcode = c('a', 'b', 'c'),
  min_qty = 0,
  max_qty = c(50, 100, 200),
  min_ndd = 0,
  max_ndd = c(10, 20, 30)
)
```

```{r pipeline}
library(dplyr)
example_therapy %>%
  # Merge with data about plausible doses and total quantities for each drug.
  left_join(plausible_values, by = 'prodcode') %>%
  # Delete implausible total quantity.
  impute_qty(method = 'replace', where = function(q) q < .$min_qty | q > .$max_qty) %>%
  # Impute missing total quantity.
  impute_qty(method = 'median', where = is.na, group = 'pracid') %>%
  # Delete implausible daily doses.
  impute_ndd(method = 'replace', where = function(d) d < .$min_ndd | d > .$max_ndd) %>%
  impute_ndd(method = 'mean', where = is.na, group = 'patid') %>%
  # Remove auxiliary range variables.
  select(-starts_with('max_'), -starts_with('min_')) %>%
  # Compute prescription duration from ndd and total qty.
  mutate(duration = qty / ndd) %>%
  # Clean overly-long durations
  clean_duration(max_months = 6, 'truncate') %>%
  # Select stop date type (this is a weird one because it could make all previous steps redundant?)
  mutate(stop_date = start_date + duration) %>% # vs numdays vs dose_duration(?)
  # Clashing stop date (maybe this step should go before the previous one?)
  impute_duration(method = 'mean', where = function(x) length(x) > 1, group = c('patid', 'start_date')) %>%
  distinct(patid, prodcode, start_date, .keep_all = TRUE) %>% # this is the only time up to this point that nrow varies
  # Overlapping prescription
  
```
OK, so that handles one run of drug preparation.

## Multiverse

How can we parametrise it for multiple sets of decisions?

With a tidy decision set, of course!

That is, we define a data frame containing vectors of values, functions and decision rules (one row per decision set) and pass it as input to a wrapper function that runs all of the above, and spits out a list of data frames of length equal to the number of rows in the decision table.

```{r}
decision_set <- list(
  implausible_qty = 'a',
  missing_qty = 'a',
  implausible_ndd = 'a',
  missing_ndd = 'a',
  clean_duration = 'a',
  select_stop_date = 'a',
  missing_stop_date = 'a',
  clash_prescription = 'a',
  overlap_prescription = 'a',
  short_gap = 'a'
)
as.data.frame(decision_set)
```

Then define a function that populates the various arguments according to these coded decision rules:

```{r}
make_decision_set <- function(decisions = c(
  # almost like a DSL
  implausible_qty = 'median pracid',
  missing_qty = 'mode population',
  implausible_ndd = 'replace',
  missing_ndd = 'mean patid',
  clean_duration = 'truncate 6',
  select_stop_date = 'stop1',
  missing_stop_date = 'mean population',
  clash_start = 'shortest',
  overlapping = 'nothing',
  short_gaps = 'nothing' ## stringr::str_split() # -> pass to function that takes list arguments
)) {
  decisions <- c
}

make_decision_set()

dp_universe <- function(data, decision, plausible_ranges) {
  data <- left_join(data, plausible_values, by = 'prodcode')
  # Decision 1
  data <- impute_qty(data, method = , where = function(q) q < .$min_qty | q > .$max_qty)
  # Decision 2
  data <- impute_qty(data, method = 'median', where = is.na, group = 'pracid')
  # Decision 3
  data <- impute_ndd(data, method = 'replace', where = function(d) d < .$min_ndd | d > .$max_ndd)
  # Decision 4
  data <- impute_ndd(data, method = 'mean', where = is.na, group = 'patid') %>%
    select(-starts_with('max_'), -starts_with('min_'))
  # Decision 5
  data <- mutate(data, duration = qty / ndd) %>%
    clean_duration(max_months = 6, 'truncate')
  # Decision 6
  data <- mutate(data, stop_date = start_date + duration)
  # Decision 7
  data <- impute_stop_date(data)
  # Decision 8
  ## Clashing start dates: not implemented yet
  # Decision 9
  ## Overlapping prescriptions: not implemented yet
  # Decision 10
  ## Gaps between prescriptions: not implemented yet
  data
}

do.call(mean, list(x = 1:2, na.rm = TRUE))


```

Practically speaking, this might consume all available memory, so it might make sense to write each table to disk rather than store them all in one list in RAM.
However, perhaps we could give the user the option, depending on data size.


